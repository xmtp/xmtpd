// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: envelopes_v2.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const insertGatewayEnvelopeV2 = `-- name: InsertGatewayEnvelopeV2 :one
WITH m AS (
    INSERT INTO gateway_envelopes_meta_v2 (
                                           originator_node_id,
                                           originator_sequence_id,
                                           topic,
                                           payer_id,
                                           gateway_time,
                                           expiry
        )
        VALUES ($1,
                $2,
                $3,
                $4,
                COALESCE($5, NOW()),
                $6)
        ON CONFLICT DO NOTHING
        RETURNING 1),
     b AS (
         INSERT INTO gateway_envelope_blobs_v2 (
                                                originator_node_id,
                                                originator_sequence_id,
                                                originator_envelope
             )
             VALUES ($1,
                     $2,
                     $7)
             ON CONFLICT DO NOTHING
             RETURNING 1)
SELECT (SELECT COUNT(*) FROM m)                            AS inserted_meta_rows,
       (SELECT COUNT(*) FROM b)                            AS inserted_blob_rows,
       (SELECT COUNT(*) FROM m) + (SELECT COUNT(*) FROM b) AS total_inserted_rows
`

type InsertGatewayEnvelopeV2Params struct {
	OriginatorNodeID     int32
	OriginatorSequenceID int64
	Topic                []byte
	PayerID              sql.NullInt32
	GatewayTime          interface{}
	Expiry               int64
	OriginatorEnvelope   []byte
}

type InsertGatewayEnvelopeV2Row struct {
	InsertedMetaRows  int64
	InsertedBlobRows  int64
	TotalInsertedRows int32
}

func (q *Queries) InsertGatewayEnvelopeV2(ctx context.Context, arg InsertGatewayEnvelopeV2Params) (InsertGatewayEnvelopeV2Row, error) {
	row := q.db.QueryRowContext(ctx, insertGatewayEnvelopeV2,
		arg.OriginatorNodeID,
		arg.OriginatorSequenceID,
		arg.Topic,
		arg.PayerID,
		arg.GatewayTime,
		arg.Expiry,
		arg.OriginatorEnvelope,
	)
	var i InsertGatewayEnvelopeV2Row
	err := row.Scan(&i.InsertedMetaRows, &i.InsertedBlobRows, &i.TotalInsertedRows)
	return i, err
}

const selectGatewayEnvelopesV2ByOriginators = `-- name: SelectGatewayEnvelopesV2ByOriginators :many
WITH cursors AS (
    SELECT x.node_id AS cursor_node_id, y.seq_id AS cursor_sequence_id
    FROM unnest($3::INT[]) WITH ORDINALITY AS x(node_id, ord)
             JOIN unnest($4::BIGINT[]) WITH ORDINALITY AS y(seq_id, ord)
                  USING (ord)
)
SELECT v.originator_node_id,
       v.originator_sequence_id,
       v.gateway_time,
       v.topic,
       v.originator_envelope
FROM gateway_envelopes_v2_view v
         LEFT JOIN cursors c
                   ON v.originator_node_id = c.cursor_node_id
WHERE v.originator_node_id = ANY($1::INT[])
  AND v.originator_sequence_id > COALESCE(c.cursor_sequence_id, 0)
ORDER BY v.gateway_time, v.originator_node_id, v.originator_sequence_id
LIMIT NULLIF($2::INT, 0)
`

type SelectGatewayEnvelopesV2ByOriginatorsParams struct {
	OriginatorNodeIds []int32
	RowLimit          int32
	CursorNodeIds     []int32
	CursorSequenceIds []int64
}

func (q *Queries) SelectGatewayEnvelopesV2ByOriginators(ctx context.Context, arg SelectGatewayEnvelopesV2ByOriginatorsParams) ([]GatewayEnvelopesV2View, error) {
	rows, err := q.db.QueryContext(ctx, selectGatewayEnvelopesV2ByOriginators,
		pq.Array(arg.OriginatorNodeIds),
		arg.RowLimit,
		pq.Array(arg.CursorNodeIds),
		pq.Array(arg.CursorSequenceIds),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GatewayEnvelopesV2View
	for rows.Next() {
		var i GatewayEnvelopesV2View
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGatewayEnvelopesV2ByTopics = `-- name: SelectGatewayEnvelopesV2ByTopics :many
WITH cursors AS (
    SELECT x.node_id AS cursor_node_id, y.seq_id AS cursor_sequence_id
    FROM unnest($3::INT[]) WITH ORDINALITY AS x(node_id, ord)
             JOIN unnest($4::BIGINT[]) WITH ORDINALITY AS y(seq_id, ord)
                  USING (ord)
)
SELECT v.originator_node_id,
       v.originator_sequence_id,
       v.gateway_time,
       v.topic,
       v.originator_envelope
FROM gateway_envelopes_v2_view v
         LEFT JOIN cursors c
                   ON v.originator_node_id = c.cursor_node_id
WHERE v.topic = ANY($1::BYTEA[])
  AND v.originator_sequence_id > COALESCE(c.cursor_sequence_id, 0)
ORDER BY v.gateway_time, v.originator_node_id, v.originator_sequence_id
LIMIT NULLIF($2::INT, 0)
`

type SelectGatewayEnvelopesV2ByTopicsParams struct {
	Topics            [][]byte
	RowLimit          int32
	CursorNodeIds     []int32
	CursorSequenceIds []int64
}

func (q *Queries) SelectGatewayEnvelopesV2ByTopics(ctx context.Context, arg SelectGatewayEnvelopesV2ByTopicsParams) ([]GatewayEnvelopesV2View, error) {
	rows, err := q.db.QueryContext(ctx, selectGatewayEnvelopesV2ByTopics,
		pq.Array(arg.Topics),
		arg.RowLimit,
		pq.Array(arg.CursorNodeIds),
		pq.Array(arg.CursorSequenceIds),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GatewayEnvelopesV2View
	for rows.Next() {
		var i GatewayEnvelopesV2View
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGatewayEnvelopesV2Unfiltered = `-- name: SelectGatewayEnvelopesV2Unfiltered :many
WITH cursors AS (SELECT x.node_id AS cursor_node_id, y.seq_id AS cursor_sequence_id
                 FROM unnest($2::INT[]) WITH ORDINALITY AS x(node_id, ord)
                          JOIN unnest($3::BIGINT[]) WITH ORDINALITY AS y(seq_id, ord)
                               USING (ord))
SELECT v.originator_node_id,
       v.originator_sequence_id,
       v.gateway_time,
       v.topic,
       v.originator_envelope
FROM gateway_envelopes_v2_view v
         LEFT JOIN cursors c
                   ON v.originator_node_id = c.cursor_node_id
WHERE v.originator_sequence_id > COALESCE(c.cursor_sequence_id, 0)
ORDER BY v.gateway_time,
         v.originator_node_id,
         v.originator_sequence_id
LIMIT NULLIF($1::INT, 0)
`

type SelectGatewayEnvelopesV2UnfilteredParams struct {
	RowLimit          int32
	CursorNodeIds     []int32
	CursorSequenceIds []int64
}

func (q *Queries) SelectGatewayEnvelopesV2Unfiltered(ctx context.Context, arg SelectGatewayEnvelopesV2UnfilteredParams) ([]GatewayEnvelopesV2View, error) {
	rows, err := q.db.QueryContext(ctx, selectGatewayEnvelopesV2Unfiltered, arg.RowLimit, pq.Array(arg.CursorNodeIds), pq.Array(arg.CursorSequenceIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GatewayEnvelopesV2View
	for rows.Next() {
		var i GatewayEnvelopesV2View
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNewestFromTopicsV2 = `-- name: SelectNewestFromTopicsV2 :many
WITH latest AS (SELECT DISTINCT ON (m.topic) m.originator_node_id,
                                             m.originator_sequence_id,
                                             m.gateway_time,
                                             m.topic
                FROM gateway_envelopes_meta_v2 m
                WHERE m.topic = ANY ($1::BYTEA[])
                ORDER BY m.topic, m.gateway_time DESC)
SELECT l.originator_node_id,
       l.originator_sequence_id,
       l.gateway_time,
       l.topic,
       b.originator_envelope
FROM latest l
         JOIN gateway_envelope_blobs_v2 b
              ON b.originator_node_id = l.originator_node_id
                  AND b.originator_sequence_id = l.originator_sequence_id
ORDER BY l.topic
`

type SelectNewestFromTopicsV2Row struct {
	OriginatorNodeID     int32
	OriginatorSequenceID int64
	GatewayTime          time.Time
	Topic                []byte
	OriginatorEnvelope   []byte
}

func (q *Queries) SelectNewestFromTopicsV2(ctx context.Context, topics [][]byte) ([]SelectNewestFromTopicsV2Row, error) {
	rows, err := q.db.QueryContext(ctx, selectNewestFromTopicsV2, pq.Array(topics))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNewestFromTopicsV2Row
	for rows.Next() {
		var i SelectNewestFromTopicsV2Row
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
