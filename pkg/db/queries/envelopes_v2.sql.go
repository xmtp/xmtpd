// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: envelopes_v2.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const insertGatewayEnvelope = `-- name: InsertGatewayEnvelope :one
WITH m AS (
    INSERT INTO gateway_envelopes_meta (
                                        originator_node_id,
                                        originator_sequence_id,
                                        topic,
                                        payer_id,
                                        gateway_time,
                                        expiry
        )
        VALUES ($1,
                $2,
                $3,
                $4,
                COALESCE($5, NOW()),
                $6)
        ON CONFLICT DO NOTHING
        RETURNING 1),
     b AS (
         INSERT INTO gateway_envelope_blobs (
                                             originator_node_id,
                                             originator_sequence_id,
                                             originator_envelope
             )
             VALUES ($1,
                     $2,
                     $7)
             ON CONFLICT DO NOTHING
             RETURNING 1)
SELECT (SELECT COUNT(*) FROM m)                            AS inserted_meta_rows,
       (SELECT COUNT(*) FROM b)                            AS inserted_blob_rows,
       (SELECT COUNT(*) FROM m) + (SELECT COUNT(*) FROM b) AS total_inserted_rows
`

type InsertGatewayEnvelopeParams struct {
	OriginatorNodeID     int32
	OriginatorSequenceID int64
	Topic                []byte
	PayerID              sql.NullInt32
	GatewayTime          interface{}
	Expiry               int64
	OriginatorEnvelope   []byte
}

type InsertGatewayEnvelopeRow struct {
	InsertedMetaRows  int64
	InsertedBlobRows  int64
	TotalInsertedRows int32
}

func (q *Queries) InsertGatewayEnvelope(ctx context.Context, arg InsertGatewayEnvelopeParams) (InsertGatewayEnvelopeRow, error) {
	row := q.db.QueryRowContext(ctx, insertGatewayEnvelope,
		arg.OriginatorNodeID,
		arg.OriginatorSequenceID,
		arg.Topic,
		arg.PayerID,
		arg.GatewayTime,
		arg.Expiry,
		arg.OriginatorEnvelope,
	)
	var i InsertGatewayEnvelopeRow
	err := row.Scan(&i.InsertedMetaRows, &i.InsertedBlobRows, &i.TotalInsertedRows)
	return i, err
}

const insertGatewayEnvelopeBatchAndIncrementUnsettledUsage = `-- name: InsertGatewayEnvelopeBatchAndIncrementUnsettledUsage :one
SELECT
    inserted_meta_rows::bigint,
    inserted_blob_rows::bigint,
    affected_usage_rows::bigint
FROM insert_gateway_envelope_batch(
    $1::int[],
    $2::bigint[],
    $3::bytea[],
    $4::int[],
    $5::timestamp[],
    $6::bigint[],
    $7::bytea[],
    $8::bigint[]
)
`

type InsertGatewayEnvelopeBatchAndIncrementUnsettledUsageParams struct {
	OriginatorNodeIds     []int32
	OriginatorSequenceIds []int64
	Topics                [][]byte
	PayerIds              []int32
	GatewayTimes          []time.Time
	Expiries              []int64
	OriginatorEnvelopes   [][]byte
	SpendPicodollars      []int64
}

type InsertGatewayEnvelopeBatchAndIncrementUnsettledUsageRow struct {
	InsertedMetaRows  int64
	InsertedBlobRows  int64
	AffectedUsageRows int64
}

func (q *Queries) InsertGatewayEnvelopeBatchAndIncrementUnsettledUsage(ctx context.Context, arg InsertGatewayEnvelopeBatchAndIncrementUnsettledUsageParams) (InsertGatewayEnvelopeBatchAndIncrementUnsettledUsageRow, error) {
	row := q.db.QueryRowContext(ctx, insertGatewayEnvelopeBatchAndIncrementUnsettledUsage,
		pq.Array(arg.OriginatorNodeIds),
		pq.Array(arg.OriginatorSequenceIds),
		pq.Array(arg.Topics),
		pq.Array(arg.PayerIds),
		pq.Array(arg.GatewayTimes),
		pq.Array(arg.Expiries),
		pq.Array(arg.OriginatorEnvelopes),
		pq.Array(arg.SpendPicodollars),
	)
	var i InsertGatewayEnvelopeBatchAndIncrementUnsettledUsageRow
	err := row.Scan(&i.InsertedMetaRows, &i.InsertedBlobRows, &i.AffectedUsageRows)
	return i, err
}

const selectGatewayEnvelopesByOriginators = `-- name: SelectGatewayEnvelopesByOriginators :many
WITH cursors AS (
    SELECT x.node_id AS cursor_node_id, y.seq_id AS cursor_sequence_id
    FROM unnest($4::INT[]) WITH ORDINALITY AS x(node_id, ord)
    JOIN unnest($5::BIGINT[]) WITH ORDINALITY AS y(seq_id, ord) USING (ord)
)
SELECT m.originator_node_id,
       m.originator_sequence_id,
       m.gateway_time,
       m.topic,
       m.originator_envelope
FROM unnest($1::INT[]) AS o(node_id)
CROSS JOIN LATERAL (
    SELECT m.originator_node_id,
           m.originator_sequence_id,
           m.gateway_time,
           m.topic,
           b.originator_envelope
    FROM gateway_envelopes_meta AS m
    JOIN gateway_envelope_blobs AS b
        ON b.originator_node_id = m.originator_node_id
       AND b.originator_sequence_id = m.originator_sequence_id
       AND b.originator_node_id = o.node_id
    WHERE m.originator_node_id = o.node_id
      AND m.originator_sequence_id > COALESCE(
          (SELECT c.cursor_sequence_id FROM cursors c WHERE c.cursor_node_id = o.node_id),
          0
      )
    ORDER BY m.originator_sequence_id
    LIMIT NULLIF($2::INT, 0)
) AS m
ORDER BY m.originator_node_id, m.originator_sequence_id
LIMIT NULLIF($3::INT, 0)
`

type SelectGatewayEnvelopesByOriginatorsParams struct {
	OriginatorNodeIds []int32
	RowsPerOriginator int32
	RowLimit          int32
	CursorNodeIds     []int32
	CursorSequenceIds []int64
}

type SelectGatewayEnvelopesByOriginatorsRow struct {
	OriginatorNodeID     int32
	OriginatorSequenceID int64
	GatewayTime          time.Time
	Topic                []byte
	OriginatorEnvelope   []byte
}

// Uses LATERAL join with scalar subquery to push cursor filter into index scan.
// This avoids full table scans when using LEFT JOIN + COALESCE pattern.
func (q *Queries) SelectGatewayEnvelopesByOriginators(ctx context.Context, arg SelectGatewayEnvelopesByOriginatorsParams) ([]SelectGatewayEnvelopesByOriginatorsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectGatewayEnvelopesByOriginators,
		pq.Array(arg.OriginatorNodeIds),
		arg.RowsPerOriginator,
		arg.RowLimit,
		pq.Array(arg.CursorNodeIds),
		pq.Array(arg.CursorSequenceIds),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectGatewayEnvelopesByOriginatorsRow
	for rows.Next() {
		var i SelectGatewayEnvelopesByOriginatorsRow
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGatewayEnvelopesBySingleOriginator = `-- name: SelectGatewayEnvelopesBySingleOriginator :many
SELECT m.originator_node_id,
       m.originator_sequence_id,
       m.gateway_time,
       m.topic,
       b.originator_envelope
FROM gateway_envelopes_meta AS m
JOIN gateway_envelope_blobs AS b
    ON b.originator_node_id = m.originator_node_id
   AND b.originator_sequence_id = m.originator_sequence_id
   AND b.originator_node_id = $1::INT
WHERE m.originator_node_id = $1::INT
  AND m.originator_sequence_id > $2::BIGINT
ORDER BY m.originator_sequence_id
LIMIT NULLIF($3::INT, 0)
`

type SelectGatewayEnvelopesBySingleOriginatorParams struct {
	OriginatorNodeID int32
	CursorSequenceID int64
	RowLimit         int32
}

type SelectGatewayEnvelopesBySingleOriginatorRow struct {
	OriginatorNodeID     int32
	OriginatorSequenceID int64
	GatewayTime          time.Time
	Topic                []byte
	OriginatorEnvelope   []byte
}

// Optimized query for a single originator - uses direct index scan
func (q *Queries) SelectGatewayEnvelopesBySingleOriginator(ctx context.Context, arg SelectGatewayEnvelopesBySingleOriginatorParams) ([]SelectGatewayEnvelopesBySingleOriginatorRow, error) {
	rows, err := q.db.QueryContext(ctx, selectGatewayEnvelopesBySingleOriginator, arg.OriginatorNodeID, arg.CursorSequenceID, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectGatewayEnvelopesBySingleOriginatorRow
	for rows.Next() {
		var i SelectGatewayEnvelopesBySingleOriginatorRow
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGatewayEnvelopesByTopics = `-- name: SelectGatewayEnvelopesByTopics :many
WITH cursors AS (
	SELECT x.node_id AS cursor_node_id, y.seq_id AS cursor_sequence_id
	FROM unnest($1::INT[]) WITH ORDINALITY AS x(node_id, ord)
	JOIN unnest($2::BIGINT[]) WITH ORDINALITY AS y(seq_id, ord)
	USING (ord)
),
cursor_entries AS (
	SELECT t.topic, c.cursor_node_id AS node_id, c.cursor_sequence_id AS seq_id
	FROM unnest($3::BYTEA[]) AS t(topic)
	CROSS JOIN cursors AS c
),
filtered AS (
	SELECT sub.originator_node_id,
	       sub.originator_sequence_id,
	       sub.gateway_time,
	       sub.topic
	FROM cursor_entries AS ce
	CROSS JOIN LATERAL (
		SELECT m.originator_node_id,
		       m.originator_sequence_id,
		       m.gateway_time,
		       m.topic
		FROM gateway_envelopes_meta AS m
		WHERE m.topic = ce.topic
		  AND m.originator_node_id = ce.node_id
		  AND m.originator_sequence_id > ce.seq_id
		ORDER BY m.originator_sequence_id
		LIMIT $4::INT
	) AS sub
	ORDER BY sub.originator_node_id, sub.originator_sequence_id
	LIMIT $4::INT
),
originator_ids AS (
	SELECT DISTINCT originator_node_id FROM filtered
)
SELECT bl.originator_node_id,
       bl.originator_sequence_id,
       bl.gateway_time,
       bl.topic,
       bl.originator_envelope
FROM originator_ids AS oi
CROSS JOIN LATERAL (
	SELECT f.originator_node_id,
	       f.originator_sequence_id,
	       f.gateway_time,
	       f.topic,
	       b.originator_envelope
	FROM filtered AS f
	JOIN gateway_envelope_blobs AS b
	    ON b.originator_node_id = oi.originator_node_id
	   AND b.originator_sequence_id = f.originator_sequence_id
	WHERE f.originator_node_id = oi.originator_node_id
) AS bl
ORDER BY bl.originator_node_id, bl.originator_sequence_id
`

type SelectGatewayEnvelopesByTopicsParams struct {
	CursorNodeIds     []int32
	CursorSequenceIds []int64
	Topics            [][]byte
	RowLimit          int32
}

type SelectGatewayEnvelopesByTopicsRow struct {
	OriginatorNodeID     int32
	OriginatorSequenceID int64
	GatewayTime          time.Time
	Topic                []byte
	OriginatorEnvelope   []byte
}

// V3b LATERAL per (topic, originator) with per-originator blob join.
// Requires callers to include ALL originators in cursor arrays (use seq_id=0 for unseen).
// Uses gem_topic_orig_seq_idx for index-only scans.
// row_limit is required and caps total rows returned.
func (q *Queries) SelectGatewayEnvelopesByTopics(ctx context.Context, arg SelectGatewayEnvelopesByTopicsParams) ([]SelectGatewayEnvelopesByTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectGatewayEnvelopesByTopics,
		pq.Array(arg.CursorNodeIds),
		pq.Array(arg.CursorSequenceIds),
		pq.Array(arg.Topics),
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectGatewayEnvelopesByTopicsRow
	for rows.Next() {
		var i SelectGatewayEnvelopesByTopicsRow
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGatewayEnvelopesUnfiltered = `-- name: SelectGatewayEnvelopesUnfiltered :many
WITH cursors AS (SELECT x.node_id AS cursor_node_id, y.seq_id AS cursor_sequence_id
                 FROM unnest($2::INT[]) WITH ORDINALITY AS x(node_id, ord)
                          JOIN unnest($3::BIGINT[]) WITH ORDINALITY AS y(seq_id, ord)
                               USING (ord))
SELECT v.originator_node_id,
       v.originator_sequence_id,
       v.gateway_time,
       v.topic,
       v.originator_envelope
FROM gateway_envelopes_view v
         LEFT JOIN cursors c
                   ON v.originator_node_id = c.cursor_node_id
WHERE v.originator_sequence_id > COALESCE(c.cursor_sequence_id, 0)
ORDER BY v.originator_node_id,
         v.originator_sequence_id
LIMIT NULLIF($1::INT, 0)
`

type SelectGatewayEnvelopesUnfilteredParams struct {
	RowLimit          int32
	CursorNodeIds     []int32
	CursorSequenceIds []int64
}

func (q *Queries) SelectGatewayEnvelopesUnfiltered(ctx context.Context, arg SelectGatewayEnvelopesUnfilteredParams) ([]GatewayEnvelopesView, error) {
	rows, err := q.db.QueryContext(ctx, selectGatewayEnvelopesUnfiltered, arg.RowLimit, pq.Array(arg.CursorNodeIds), pq.Array(arg.CursorSequenceIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GatewayEnvelopesView
	for rows.Next() {
		var i GatewayEnvelopesView
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNewestFromTopics = `-- name: SelectNewestFromTopics :many
WITH latest AS (SELECT DISTINCT ON (m.topic) m.originator_node_id,
                                             m.originator_sequence_id,
                                             m.gateway_time,
                                             m.topic
                FROM gateway_envelopes_meta m
                WHERE m.topic = ANY ($1::BYTEA[])
                ORDER BY m.topic, m.gateway_time DESC)
SELECT l.originator_node_id,
       l.originator_sequence_id,
       l.gateway_time,
       l.topic,
       b.originator_envelope
FROM latest l
         JOIN gateway_envelope_blobs b
              ON b.originator_node_id = l.originator_node_id
                  AND b.originator_sequence_id = l.originator_sequence_id
ORDER BY l.topic
`

type SelectNewestFromTopicsRow struct {
	OriginatorNodeID     int32
	OriginatorSequenceID int64
	GatewayTime          time.Time
	Topic                []byte
	OriginatorEnvelope   []byte
}

// TODO(mkysel) -- sorting by gateway time can lead to wrong results, this query needs to be redone
func (q *Queries) SelectNewestFromTopics(ctx context.Context, topics [][]byte) ([]SelectNewestFromTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNewestFromTopics, pq.Array(topics))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNewestFromTopicsRow
	for rows.Next() {
		var i SelectNewestFromTopicsRow
		if err := rows.Scan(
			&i.OriginatorNodeID,
			&i.OriginatorSequenceID,
			&i.GatewayTime,
			&i.Topic,
			&i.OriginatorEnvelope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
