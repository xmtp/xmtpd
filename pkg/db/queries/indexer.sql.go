// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: indexer.sql

package queries

import (
	"context"
)

const getLatestBlock = `-- name: GetLatestBlock :one
SELECT
	block_number,
	block_hash
FROM
	latest_block
WHERE
	contract_address = $1
`

type GetLatestBlockRow struct {
	BlockNumber int64
	BlockHash   []byte
}

func (q *Queries) GetLatestBlock(ctx context.Context, contractAddress string) (GetLatestBlockRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestBlock, contractAddress)
	var i GetLatestBlockRow
	err := row.Scan(&i.BlockNumber, &i.BlockHash)
	return i, err
}

const setLatestBlock = `-- name: SetLatestBlock :exec
INSERT INTO latest_block(contract_address, block_number, block_hash)
	VALUES ($1, $2, $3)
ON CONFLICT (contract_address)
	DO UPDATE SET
		block_number = $2, block_hash = $3
	WHERE
		$2 > latest_block.block_number
		AND $3 != latest_block.block_hash
`

type SetLatestBlockParams struct {
	ContractAddress string
	BlockNumber     int64
	BlockHash       []byte
}

func (q *Queries) SetLatestBlock(ctx context.Context, arg SetLatestBlockParams) error {
	_, err := q.db.ExecContext(ctx, setLatestBlock, arg.ContractAddress, arg.BlockNumber, arg.BlockHash)
	return err
}
