// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: nonceManager.sql

package queries

import (
	"context"
)

const deleteAvailableNonce = `-- name: DeleteAvailableNonce :execrows
DELETE FROM nonce_table
WHERE nonce = $1
`

func (q *Queries) DeleteAvailableNonce(ctx context.Context, nonce int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAvailableNonce, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteObsoleteNonces = `-- name: DeleteObsoleteNonces :execrows
WITH deletable AS (
	SELECT
		n.nonce
	FROM
		nonce_table n
	WHERE
		n.nonce < $1
	FOR UPDATE
		SKIP LOCKED)
DELETE FROM nonce_table USING deletable
WHERE nonce_table.nonce = deletable.nonce
`

func (q *Queries) DeleteObsoleteNonces(ctx context.Context, nonce int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteObsoleteNonces, nonce)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const fillNonceSequence = `-- name: FillNonceSequence :one
SELECT COALESCE(
		fill_nonce_gap($1, $2),
		$2
	)::INT AS inserted_rows
`

type FillNonceSequenceParams struct {
	PendingNonce int64
	NumElements  int32
}

func (q *Queries) FillNonceSequence(ctx context.Context, arg FillNonceSequenceParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, fillNonceSequence, arg.PendingNonce, arg.NumElements)
	var inserted_rows int32
	err := row.Scan(&inserted_rows)
	return inserted_rows, err
}

const getNextAvailableNonce = `-- name: GetNextAvailableNonce :one
SELECT nonce
FROM nonce_table
ORDER BY nonce ASC
LIMIT 1 FOR
UPDATE SKIP LOCKED
`

func (q *Queries) GetNextAvailableNonce(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNextAvailableNonce)
	var nonce int64
	err := row.Scan(&nonce)
	return nonce, err
}
