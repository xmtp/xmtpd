// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payerReports.sql

package queries

import (
	"context"
)

const buildPayerReport = `-- name: BuildPayerReport :many
SELECT
	payers.address as payer_address,
	SUM(spend_picodollars)::BIGINT AS total_spend_picodollars
FROM
	unsettled_usage
JOIN payers on payers.id = unsettled_usage.payer_id
WHERE
	originator_id = $1
	AND minutes_since_epoch > $2
	AND minutes_since_epoch <= $3
GROUP BY
	payers.address
`

type BuildPayerReportParams struct {
	OriginatorID           int32
	StartMinutesSinceEpoch int32
	EndMinutesSinceEpoch   int32
}

type BuildPayerReportRow struct {
	PayerAddress          string
	TotalSpendPicodollars int64
}

func (q *Queries) BuildPayerReport(ctx context.Context, arg BuildPayerReportParams) ([]BuildPayerReportRow, error) {
	rows, err := q.db.QueryContext(ctx, buildPayerReport, arg.OriginatorID, arg.StartMinutesSinceEpoch, arg.EndMinutesSinceEpoch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BuildPayerReportRow
	for rows.Next() {
		var i BuildPayerReportRow
		if err := rows.Scan(&i.PayerAddress, &i.TotalSpendPicodollars); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrCreatePayer = `-- name: FindOrCreatePayer :one
INSERT INTO payers(address)
	VALUES ($1)
ON CONFLICT (address)
	DO UPDATE SET
		address = $1
	RETURNING
		id
`

func (q *Queries) FindOrCreatePayer(ctx context.Context, address string) (int32, error) {
	row := q.db.QueryRowContext(ctx, findOrCreatePayer, address)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getGatewayEnvelopeByID = `-- name: GetGatewayEnvelopeByID :one
SELECT gateway_time, originator_node_id, originator_sequence_id, topic, originator_envelope, payer_id FROM gateway_envelopes
WHERE originator_sequence_id = $1
AND originator_node_id = $2
`

type GetGatewayEnvelopeByIDParams struct {
	OriginatorSequenceID int64
	OriginatorNodeID     int32
}

// Include the node ID to take advantage of the primary key index
func (q *Queries) GetGatewayEnvelopeByID(ctx context.Context, arg GetGatewayEnvelopeByIDParams) (GatewayEnvelope, error) {
	row := q.db.QueryRowContext(ctx, getGatewayEnvelopeByID, arg.OriginatorSequenceID, arg.OriginatorNodeID)
	var i GatewayEnvelope
	err := row.Scan(
		&i.GatewayTime,
		&i.OriginatorNodeID,
		&i.OriginatorSequenceID,
		&i.Topic,
		&i.OriginatorEnvelope,
		&i.PayerID,
	)
	return i, err
}

const getPayerUnsettledUsage = `-- name: GetPayerUnsettledUsage :one
SELECT
	COALESCE(SUM(spend_picodollars), 0)::BIGINT AS total_spend_picodollars,
	COALESCE(MAX(last_sequence_id), 0)::BIGINT AS last_sequence_id
FROM
	unsettled_usage
WHERE
	payer_id = $1
	AND ($2::BIGINT = 0
		OR minutes_since_epoch > $2::BIGINT)
	AND ($3::BIGINT = 0
		OR minutes_since_epoch < $3::BIGINT)
`

type GetPayerUnsettledUsageParams struct {
	PayerID             int32
	MinutesSinceEpochGt int64
	MinutesSinceEpochLt int64
}

type GetPayerUnsettledUsageRow struct {
	TotalSpendPicodollars int64
	LastSequenceID        int64
}

func (q *Queries) GetPayerUnsettledUsage(ctx context.Context, arg GetPayerUnsettledUsageParams) (GetPayerUnsettledUsageRow, error) {
	row := q.db.QueryRowContext(ctx, getPayerUnsettledUsage, arg.PayerID, arg.MinutesSinceEpochGt, arg.MinutesSinceEpochLt)
	var i GetPayerUnsettledUsageRow
	err := row.Scan(&i.TotalSpendPicodollars, &i.LastSequenceID)
	return i, err
}

const getSecondNewestMinute = `-- name: GetSecondNewestMinute :one
WITH second_newest_minute
AS
  (
           SELECT minutes_since_epoch
           FROM     unsettled_usage
           WHERE    originator_id = $1
           AND      unsettled_usage.minutes_since_epoch > $2
           GROUP BY unsettled_usage.minutes_since_epoch
           ORDER BY unsettled_usage.minutes_since_epoch DESC
           LIMIT    1
           OFFSET   1)
  SELECT coalesce(max(last_sequence_id), 0)::BIGINT as max_sequence_id,
         coalesce(max(unsettled_usage.minutes_since_epoch), 0)::INT as minutes_since_epoch
  FROM   unsettled_usage
  JOIN   second_newest_minute
  ON     second_newest_minute.minutes_since_epoch = unsettled_usage.minutes_since_epoch
  WHERE  unsettled_usage.originator_id = $1
`

type GetSecondNewestMinuteParams struct {
	OriginatorID             int32
	MinimumMinutesSinceEpoch int32
}

type GetSecondNewestMinuteRow struct {
	MaxSequenceID     int64
	MinutesSinceEpoch int32
}

func (q *Queries) GetSecondNewestMinute(ctx context.Context, arg GetSecondNewestMinuteParams) (GetSecondNewestMinuteRow, error) {
	row := q.db.QueryRowContext(ctx, getSecondNewestMinute, arg.OriginatorID, arg.MinimumMinutesSinceEpoch)
	var i GetSecondNewestMinuteRow
	err := row.Scan(&i.MaxSequenceID, &i.MinutesSinceEpoch)
	return i, err
}

const incrementUnsettledUsage = `-- name: IncrementUnsettledUsage :exec
INSERT INTO unsettled_usage(payer_id, originator_id, minutes_since_epoch, spend_picodollars, last_sequence_id)
	VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (payer_id, originator_id, minutes_since_epoch)
	DO UPDATE SET
		spend_picodollars = unsettled_usage.spend_picodollars + $4,
		last_sequence_id = GREATEST(unsettled_usage.last_sequence_id, $5)
`

type IncrementUnsettledUsageParams struct {
	PayerID           int32
	OriginatorID      int32
	MinutesSinceEpoch int32
	SpendPicodollars  int64
	SequenceID        int64
}

func (q *Queries) IncrementUnsettledUsage(ctx context.Context, arg IncrementUnsettledUsageParams) error {
	_, err := q.db.ExecContext(ctx, incrementUnsettledUsage,
		arg.PayerID,
		arg.OriginatorID,
		arg.MinutesSinceEpoch,
		arg.SpendPicodollars,
		arg.SequenceID,
	)
	return err
}
