// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payer_reports.sql

package queries

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const buildPayerReport = `-- name: BuildPayerReport :many
SELECT payers.address AS payer_address,
	SUM(spend_picodollars)::BIGINT AS total_spend_picodollars
FROM unsettled_usage
	JOIN payers ON payers.id = unsettled_usage.payer_id
WHERE originator_id = $1
	AND minutes_since_epoch > $2
	AND minutes_since_epoch <= $3
GROUP BY payers.address
`

type BuildPayerReportParams struct {
	OriginatorID           int32
	StartMinutesSinceEpoch int32
	EndMinutesSinceEpoch   int32
}

type BuildPayerReportRow struct {
	PayerAddress          string
	TotalSpendPicodollars int64
}

func (q *Queries) BuildPayerReport(ctx context.Context, arg BuildPayerReportParams) ([]BuildPayerReportRow, error) {
	rows, err := q.db.QueryContext(ctx, buildPayerReport, arg.OriginatorID, arg.StartMinutesSinceEpoch, arg.EndMinutesSinceEpoch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BuildPayerReportRow
	for rows.Next() {
		var i BuildPayerReportRow
		if err := rows.Scan(&i.PayerAddress, &i.TotalSpendPicodollars); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const clearUnsettledUsage = `-- name: ClearUnsettledUsage :exec
DELETE FROM unsettled_usage
WHERE originator_id = $1
	AND minutes_since_epoch > $2
	AND minutes_since_epoch <= $3
`

type ClearUnsettledUsageParams struct {
	OriginatorID                  int32
	PrevReportEndMinuteSinceEpoch int32
	EndMinuteSinceEpoch           int32
}

func (q *Queries) ClearUnsettledUsage(ctx context.Context, arg ClearUnsettledUsageParams) error {
	_, err := q.db.ExecContext(ctx, clearUnsettledUsage, arg.OriginatorID, arg.PrevReportEndMinuteSinceEpoch, arg.EndMinuteSinceEpoch)
	return err
}

const fetchAttestations = `-- name: FetchAttestations :many
SELECT payer_report_id, node_id, signature, payer_report_attestations.created_at, id, originator_node_id, start_sequence_id, end_sequence_id, end_minute_since_epoch, payers_merkle_root, active_node_ids, submission_status, attestation_status, payer_reports.created_at, submitted_report_index
FROM payer_report_attestations
	LEFT JOIN payer_reports ON payer_reports.id = payer_report_attestations.payer_report_id
WHERE (
		$1::BYTEA IS NULL
		OR $1::BYTEA = payer_report_id
	)
	AND (
		$2::INT IS NULL
		OR $2::INT = node_id
	)
`

type FetchAttestationsParams struct {
	PayerReportID  []byte
	AttesterNodeID sql.NullInt32
}

type FetchAttestationsRow struct {
	PayerReportID        []byte
	NodeID               int64
	Signature            []byte
	CreatedAt            sql.NullTime
	ID                   []byte
	OriginatorNodeID     sql.NullInt32
	StartSequenceID      sql.NullInt64
	EndSequenceID        sql.NullInt64
	EndMinuteSinceEpoch  sql.NullInt32
	PayersMerkleRoot     []byte
	ActiveNodeIds        []int32
	SubmissionStatus     sql.NullInt16
	AttestationStatus    sql.NullInt16
	CreatedAt_2          sql.NullTime
	SubmittedReportIndex sql.NullInt32
}

func (q *Queries) FetchAttestations(ctx context.Context, arg FetchAttestationsParams) ([]FetchAttestationsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAttestations, arg.PayerReportID, arg.AttesterNodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAttestationsRow
	for rows.Next() {
		var i FetchAttestationsRow
		if err := rows.Scan(
			&i.PayerReportID,
			&i.NodeID,
			&i.Signature,
			&i.CreatedAt,
			&i.ID,
			&i.OriginatorNodeID,
			&i.StartSequenceID,
			&i.EndSequenceID,
			&i.EndMinuteSinceEpoch,
			&i.PayersMerkleRoot,
			pq.Array(&i.ActiveNodeIds),
			&i.SubmissionStatus,
			&i.AttestationStatus,
			&i.CreatedAt_2,
			&i.SubmittedReportIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPayerReport = `-- name: FetchPayerReport :one
SELECT id, originator_node_id, start_sequence_id, end_sequence_id, end_minute_since_epoch, payers_merkle_root, active_node_ids, submission_status, attestation_status, created_at, submitted_report_index
FROM payer_reports
WHERE id = $1
`

func (q *Queries) FetchPayerReport(ctx context.Context, id []byte) (PayerReport, error) {
	row := q.db.QueryRowContext(ctx, fetchPayerReport, id)
	var i PayerReport
	err := row.Scan(
		&i.ID,
		&i.OriginatorNodeID,
		&i.StartSequenceID,
		&i.EndSequenceID,
		&i.EndMinuteSinceEpoch,
		&i.PayersMerkleRoot,
		pq.Array(&i.ActiveNodeIds),
		&i.SubmissionStatus,
		&i.AttestationStatus,
		&i.CreatedAt,
		&i.SubmittedReportIndex,
	)
	return i, err
}

const fetchPayerReportLocked = `-- name: FetchPayerReportLocked :one
SELECT id, originator_node_id, start_sequence_id, end_sequence_id, end_minute_since_epoch, payers_merkle_root, active_node_ids, submission_status, attestation_status, created_at, submitted_report_index
FROM payer_reports
WHERE id = $1
FOR UPDATE
`

func (q *Queries) FetchPayerReportLocked(ctx context.Context, id []byte) (PayerReport, error) {
	row := q.db.QueryRowContext(ctx, fetchPayerReportLocked, id)
	var i PayerReport
	err := row.Scan(
		&i.ID,
		&i.OriginatorNodeID,
		&i.StartSequenceID,
		&i.EndSequenceID,
		&i.EndMinuteSinceEpoch,
		&i.PayersMerkleRoot,
		pq.Array(&i.ActiveNodeIds),
		&i.SubmissionStatus,
		&i.AttestationStatus,
		&i.CreatedAt,
		&i.SubmittedReportIndex,
	)
	return i, err
}

const fetchPayerReports = `-- name: FetchPayerReports :many
WITH rpt AS (
	SELECT pr.id, pr.originator_node_id, pr.start_sequence_id, pr.end_sequence_id, pr.end_minute_since_epoch, pr.payers_merkle_root, pr.active_node_ids, pr.submission_status, pr.attestation_status, pr.created_at, pr.submitted_report_index,
		pra.node_id,
		pra.signature,
		COUNT(pra.node_id) OVER (PARTITION BY pr.id) AS attestations_count
	FROM payer_reports AS pr
		LEFT JOIN payer_report_attestations AS pra ON pra.payer_report_id = pr.id
	WHERE (
			$2::SMALLINT [] IS NULL
			OR pr.attestation_status = ANY($2::SMALLINT [])
		)
		AND (
			$3::SMALLINT [] IS NULL
			OR pr.submission_status = ANY($3::SMALLINT [])
		)
		AND (
			$4::TIMESTAMP IS NULL
			OR pr.created_at > $4
		)
		AND (
			$5::BIGINT IS NULL
			OR $5 = pr.end_sequence_id
		)
		AND (
			$6::BIGINT IS NULL
			OR $6 = pr.start_sequence_id
		)
		AND (
			$7::INT IS NULL
			OR $7 = pr.originator_node_id
		)
		AND (
			$8::BYTEA IS NULL
			OR $8::BYTEA = pr.id
		)
)
SELECT id, originator_node_id, start_sequence_id, end_sequence_id, end_minute_since_epoch, payers_merkle_root, active_node_ids, submission_status, attestation_status, created_at, submitted_report_index, node_id, signature, attestations_count
FROM rpt
WHERE $1::INT IS NULL
	OR attestations_count >= $1::INT
ORDER BY created_at ASC
`

type FetchPayerReportsParams struct {
	MinAttestations     sql.NullInt32
	AttestationStatusIn []int16
	SubmissionStatusIn  []int16
	CreatedAfter        sql.NullTime
	EndSequenceID       sql.NullInt64
	StartSequenceID     sql.NullInt64
	OriginatorNodeID    sql.NullInt32
	PayerReportID       []byte
}

type FetchPayerReportsRow struct {
	ID                   []byte
	OriginatorNodeID     int32
	StartSequenceID      int64
	EndSequenceID        int64
	EndMinuteSinceEpoch  int32
	PayersMerkleRoot     []byte
	ActiveNodeIds        []int32
	SubmissionStatus     int16
	AttestationStatus    int16
	CreatedAt            sql.NullTime
	SubmittedReportIndex sql.NullInt32
	NodeID               sql.NullInt64
	Signature            []byte
	AttestationsCount    int64
}

func (q *Queries) FetchPayerReports(ctx context.Context, arg FetchPayerReportsParams) ([]FetchPayerReportsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPayerReports,
		arg.MinAttestations,
		pq.Array(arg.AttestationStatusIn),
		pq.Array(arg.SubmissionStatusIn),
		arg.CreatedAfter,
		arg.EndSequenceID,
		arg.StartSequenceID,
		arg.OriginatorNodeID,
		arg.PayerReportID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPayerReportsRow
	for rows.Next() {
		var i FetchPayerReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginatorNodeID,
			&i.StartSequenceID,
			&i.EndSequenceID,
			&i.EndMinuteSinceEpoch,
			&i.PayersMerkleRoot,
			pq.Array(&i.ActiveNodeIds),
			&i.SubmissionStatus,
			&i.AttestationStatus,
			&i.CreatedAt,
			&i.SubmittedReportIndex,
			&i.NodeID,
			&i.Signature,
			&i.AttestationsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrCreatePayer = `-- name: FindOrCreatePayer :one
WITH ins AS (
  INSERT INTO payers(address)
  VALUES ($1)
  ON CONFLICT (address) DO NOTHING
  RETURNING id
), u AS (
  SELECT id FROM ins
  UNION ALL
  SELECT id FROM payers WHERE address = $1
)
SELECT id
FROM u
LIMIT 1
`

func (q *Queries) FindOrCreatePayer(ctx context.Context, address string) (int32, error) {
	row := q.db.QueryRowContext(ctx, findOrCreatePayer, address)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getGatewayEnvelopeByID = `-- name: GetGatewayEnvelopeByID :one
SELECT originator_node_id, originator_sequence_id, gateway_time, topic, originator_envelope
FROM gateway_envelopes_view
WHERE originator_sequence_id = $1 -- Include the node ID to take advantage of the primary key index
	AND originator_node_id = $2
`

type GetGatewayEnvelopeByIDParams struct {
	OriginatorSequenceID int64
	OriginatorNodeID     int32
}

func (q *Queries) GetGatewayEnvelopeByID(ctx context.Context, arg GetGatewayEnvelopeByIDParams) (GatewayEnvelopesView, error) {
	row := q.db.QueryRowContext(ctx, getGatewayEnvelopeByID, arg.OriginatorSequenceID, arg.OriginatorNodeID)
	var i GatewayEnvelopesView
	err := row.Scan(
		&i.OriginatorNodeID,
		&i.OriginatorSequenceID,
		&i.GatewayTime,
		&i.Topic,
		&i.OriginatorEnvelope,
	)
	return i, err
}

const getLastSequenceIDForOriginatorMinute = `-- name: GetLastSequenceIDForOriginatorMinute :one
SELECT COALESCE(MAX(last_sequence_id), 0)::BIGINT AS last_sequence_id
FROM unsettled_usage
WHERE originator_id = $1
	AND minutes_since_epoch = $2
`

type GetLastSequenceIDForOriginatorMinuteParams struct {
	OriginatorID      int32
	MinutesSinceEpoch int32
}

func (q *Queries) GetLastSequenceIDForOriginatorMinute(ctx context.Context, arg GetLastSequenceIDForOriginatorMinuteParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLastSequenceIDForOriginatorMinute, arg.OriginatorID, arg.MinutesSinceEpoch)
	var last_sequence_id int64
	err := row.Scan(&last_sequence_id)
	return last_sequence_id, err
}

const getPayerByAddress = `-- name: GetPayerByAddress :one
SELECT id
FROM payers
WHERE address = $1
`

func (q *Queries) GetPayerByAddress(ctx context.Context, address string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPayerByAddress, address)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPayerInfoReport = `-- name: GetPayerInfoReport :many
SELECT EXTRACT(
		EPOCH
		FROM DATE_TRUNC(
				CASE
					WHEN $1 = 'hour' THEN 'hour'
					ELSE 'day'
				END,
				TO_TIMESTAMP(minutes_since_epoch * 60)
			)
	)::BIGINT AS time_period,
	COALESCE(SUM(spend_picodollars), 0)::BIGINT AS total_spend_picodollars,
	COALESCE(SUM(message_count), 0)::INTEGER AS total_message_count
FROM unsettled_usage
WHERE payer_id = $2
GROUP BY time_period
ORDER BY time_period
`

type GetPayerInfoReportParams struct {
	GroupBy interface{}
	PayerID int32
}

type GetPayerInfoReportRow struct {
	TimePeriod            int64
	TotalSpendPicodollars int64
	TotalMessageCount     int32
}

func (q *Queries) GetPayerInfoReport(ctx context.Context, arg GetPayerInfoReportParams) ([]GetPayerInfoReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getPayerInfoReport, arg.GroupBy, arg.PayerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPayerInfoReportRow
	for rows.Next() {
		var i GetPayerInfoReportRow
		if err := rows.Scan(&i.TimePeriod, &i.TotalSpendPicodollars, &i.TotalMessageCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayerUnsettledUsage = `-- name: GetPayerUnsettledUsage :one
SELECT COALESCE(SUM(spend_picodollars), 0)::BIGINT AS total_spend_picodollars,
	COALESCE(MAX(last_sequence_id), 0)::BIGINT AS last_sequence_id
FROM unsettled_usage
WHERE payer_id = $1
	AND (
		$2::BIGINT = 0
		OR minutes_since_epoch > $2::BIGINT
	)
	AND (
		$3::BIGINT = 0
		OR minutes_since_epoch < $3::BIGINT
	)
`

type GetPayerUnsettledUsageParams struct {
	PayerID             int32
	MinutesSinceEpochGt int64
	MinutesSinceEpochLt int64
}

type GetPayerUnsettledUsageRow struct {
	TotalSpendPicodollars int64
	LastSequenceID        int64
}

func (q *Queries) GetPayerUnsettledUsage(ctx context.Context, arg GetPayerUnsettledUsageParams) (GetPayerUnsettledUsageRow, error) {
	row := q.db.QueryRowContext(ctx, getPayerUnsettledUsage, arg.PayerID, arg.MinutesSinceEpochGt, arg.MinutesSinceEpochLt)
	var i GetPayerUnsettledUsageRow
	err := row.Scan(&i.TotalSpendPicodollars, &i.LastSequenceID)
	return i, err
}

const getSecondNewestMinute = `-- name: GetSecondNewestMinute :one
WITH second_newest_minute AS (
	SELECT minutes_since_epoch
	FROM unsettled_usage
	WHERE originator_id = $1
		AND unsettled_usage.minutes_since_epoch > $2
	GROUP BY unsettled_usage.minutes_since_epoch
	ORDER BY unsettled_usage.minutes_since_epoch DESC
	LIMIT 1 OFFSET 1
)
SELECT coalesce(max(last_sequence_id), 0)::BIGINT AS max_sequence_id,
	coalesce(max(unsettled_usage.minutes_since_epoch), 0)::INT AS minutes_since_epoch
FROM unsettled_usage
	JOIN second_newest_minute ON second_newest_minute.minutes_since_epoch = unsettled_usage.minutes_since_epoch
WHERE unsettled_usage.originator_id = $1
`

type GetSecondNewestMinuteParams struct {
	OriginatorID             int32
	MinimumMinutesSinceEpoch int32
}

type GetSecondNewestMinuteRow struct {
	MaxSequenceID     int64
	MinutesSinceEpoch int32
}

func (q *Queries) GetSecondNewestMinute(ctx context.Context, arg GetSecondNewestMinuteParams) (GetSecondNewestMinuteRow, error) {
	row := q.db.QueryRowContext(ctx, getSecondNewestMinute, arg.OriginatorID, arg.MinimumMinutesSinceEpoch)
	var i GetSecondNewestMinuteRow
	err := row.Scan(&i.MaxSequenceID, &i.MinutesSinceEpoch)
	return i, err
}

const incrementUnsettledUsage = `-- name: IncrementUnsettledUsage :exec
INSERT INTO unsettled_usage(
		payer_id,
		originator_id,
		minutes_since_epoch,
		spend_picodollars,
		last_sequence_id,
		message_count
	)
VALUES (
		$1,
		$2,
		$3,
		$4,
		$5,
		$6
	) ON CONFLICT (payer_id, originator_id, minutes_since_epoch) DO
UPDATE
SET spend_picodollars = unsettled_usage.spend_picodollars + $4,
	message_count = unsettled_usage.message_count + $6,
	last_sequence_id = GREATEST(unsettled_usage.last_sequence_id, $5)
`

type IncrementUnsettledUsageParams struct {
	PayerID           int32
	OriginatorID      int32
	MinutesSinceEpoch int32
	SpendPicodollars  int64
	SequenceID        int64
	MessageCount      int32
}

func (q *Queries) IncrementUnsettledUsage(ctx context.Context, arg IncrementUnsettledUsageParams) error {
	_, err := q.db.ExecContext(ctx, incrementUnsettledUsage,
		arg.PayerID,
		arg.OriginatorID,
		arg.MinutesSinceEpoch,
		arg.SpendPicodollars,
		arg.SequenceID,
		arg.MessageCount,
	)
	return err
}

const insertOrIgnorePayerReport = `-- name: InsertOrIgnorePayerReport :execrows
INSERT INTO payer_reports (
		id,
		originator_node_id,
		start_sequence_id,
		end_sequence_id,
		end_minute_since_epoch,
		payers_merkle_root,
		active_node_ids
	)
VALUES (
		$1,
		$2,
		$3,
		$4,
		$5,
		$6,
		$7
	) ON CONFLICT (id) DO NOTHING
`

type InsertOrIgnorePayerReportParams struct {
	ID                  []byte
	OriginatorNodeID    int32
	StartSequenceID     int64
	EndSequenceID       int64
	EndMinuteSinceEpoch int32
	PayersMerkleRoot    []byte
	ActiveNodeIds       []int32
}

func (q *Queries) InsertOrIgnorePayerReport(ctx context.Context, arg InsertOrIgnorePayerReportParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertOrIgnorePayerReport,
		arg.ID,
		arg.OriginatorNodeID,
		arg.StartSequenceID,
		arg.EndSequenceID,
		arg.EndMinuteSinceEpoch,
		arg.PayersMerkleRoot,
		pq.Array(arg.ActiveNodeIds),
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertOrIgnorePayerReportAttestation = `-- name: InsertOrIgnorePayerReportAttestation :exec
INSERT INTO payer_report_attestations (payer_report_id, node_id, signature)
VALUES ($1, $2, $3) ON CONFLICT (payer_report_id, node_id) DO NOTHING
`

type InsertOrIgnorePayerReportAttestationParams struct {
	PayerReportID []byte
	NodeID        int64
	Signature     []byte
}

func (q *Queries) InsertOrIgnorePayerReportAttestation(ctx context.Context, arg InsertOrIgnorePayerReportAttestationParams) error {
	_, err := q.db.ExecContext(ctx, insertOrIgnorePayerReportAttestation, arg.PayerReportID, arg.NodeID, arg.Signature)
	return err
}

const setReportAttestationStatus = `-- name: SetReportAttestationStatus :exec
UPDATE payer_reports
SET attestation_status = $1
WHERE id = $2
	AND attestation_status = ANY($3::SMALLINT [])
`

type SetReportAttestationStatusParams struct {
	NewStatus  int16
	ReportID   []byte
	PrevStatus []int16
}

func (q *Queries) SetReportAttestationStatus(ctx context.Context, arg SetReportAttestationStatusParams) error {
	_, err := q.db.ExecContext(ctx, setReportAttestationStatus, arg.NewStatus, arg.ReportID, pq.Array(arg.PrevStatus))
	return err
}

const setReportSubmissionStatus = `-- name: SetReportSubmissionStatus :exec
UPDATE payer_reports
SET submission_status = $1
WHERE id = $2
	AND submission_status = ANY($3::SMALLINT [])
`

type SetReportSubmissionStatusParams struct {
	NewStatus  int16
	ReportID   []byte
	PrevStatus []int16
}

func (q *Queries) SetReportSubmissionStatus(ctx context.Context, arg SetReportSubmissionStatusParams) error {
	_, err := q.db.ExecContext(ctx, setReportSubmissionStatus, arg.NewStatus, arg.ReportID, pq.Array(arg.PrevStatus))
	return err
}

const setReportSubmitted = `-- name: SetReportSubmitted :exec
UPDATE payer_reports
SET submission_status = $1,
	submitted_report_index = $2::INTEGER
WHERE id = $3
	AND submission_status = ANY($4::SMALLINT [])
`

type SetReportSubmittedParams struct {
	NewStatus            int16
	SubmittedReportIndex int32
	ReportID             []byte
	PrevStatus           []int16
}

func (q *Queries) SetReportSubmitted(ctx context.Context, arg SetReportSubmittedParams) error {
	_, err := q.db.ExecContext(ctx, setReportSubmitted,
		arg.NewStatus,
		arg.SubmittedReportIndex,
		arg.ReportID,
		pq.Array(arg.PrevStatus),
	)
	return err
}
