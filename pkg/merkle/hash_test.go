package merkle_test

import (
	"bytes"
	"testing"

	"github.com/xmtp/xmtpd/pkg/merkle"
)

func TestHash(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected []byte
	}{
		{
			"A",
			[]byte("Hello"),
			[]byte{6, 179, 223, 174, 193, 72, 251, 27, 178, 176, 102, 241, 14, 194, 133, 231, 201, 191, 64, 42, 179, 42, 167, 138, 93, 56, 227, 69, 102, 129, 12, 210},
		},
		{
			"B",
			[]byte("World"),
			[]byte{242, 32, 140, 150, 125, 240, 137, 246, 4, 32, 120, 87, 149, 192, 169, 186, 136, 150, 176, 246, 241, 134, 127, 167, 241, 241, 42, 214, 247, 156, 26, 24},
		},
		{
			"C",
			[]byte("Lorem ipsum dolor sit amet"),
			[]byte{181, 59, 124, 165, 21, 5, 29, 73, 232, 81, 192, 123, 208, 251, 221, 219, 128, 16, 169, 54, 111, 91, 31, 95, 183, 55, 186, 33, 164, 53, 99, 1},
		},
		{
			"D",
			[]byte("Lorem ipsum dolor sit amet consectetur adipiscing elit"),
			[]byte{220, 97, 186, 80, 239, 126, 118, 1, 135, 119, 215, 176, 233, 190, 140, 95, 143, 146, 142, 230, 89, 123, 151, 144, 81, 148, 234, 226, 116, 108, 221, 129},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.Hash(tt.input)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"Hash of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashLeaf(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected []byte
	}{
		{
			"A",
			[]byte("Hello"),
			[]byte{11, 143, 170, 141, 208, 138, 23, 46, 191, 149, 130, 239, 28, 115, 208, 106, 130, 226, 141, 24, 198, 26, 139, 71, 177, 61, 1, 241, 116, 14, 154, 17},
		},
		{
			"B",
			[]byte("World"),
			[]byte{129, 125, 90, 71, 216, 243, 130, 116, 25, 154, 245, 121, 7, 170, 32, 166, 51, 165, 247, 103, 67, 156, 252, 34, 225, 26, 93, 213, 164, 73, 63, 42},
		},
		{
			"C",
			[]byte("Lorem ipsum dolor sit amet"),
			[]byte{165, 220, 67, 4, 77, 184, 119, 172, 239, 129, 129, 176, 75, 120, 168, 28, 57, 160, 29, 139, 167, 142, 41, 165, 254, 6, 169, 151, 50, 230, 38, 211},
		},
		{
			"D",
			[]byte("Lorem ipsum dolor sit amet consectetur adipiscing elit"),
			[]byte{165, 254, 22, 5, 66, 70, 236, 85, 180, 196, 243, 118, 228, 50, 204, 233, 245, 215, 233, 198, 133, 155, 242, 128, 28, 29, 5, 224, 161, 135, 52, 28},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.HashLeaf(tt.input)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"HashLeaf of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashNodePair(t *testing.T) {
	tests := []struct {
		name     string
		left     []byte
		right    []byte
		expected []byte
	}{
		{
			"A",
			[]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			[]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			[]byte{48, 192, 143, 23, 252, 166, 213, 177, 131, 253, 121, 141, 242, 201, 75, 229, 95, 145, 145, 170, 23, 182, 78, 20, 175, 36, 222, 165, 29, 86, 162, 0},
		},
		{
			"B",
			[]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			[]byte{31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			[]byte{175, 69, 169, 211, 205, 37, 100, 136, 146, 142, 150, 69, 138, 15, 230, 189, 230, 24, 44, 65, 109, 173, 98, 40, 193, 89, 0, 87, 10, 212, 206, 134},
		},
		{
			"C",
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			[]byte{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
			[]byte{207, 134, 175, 117, 168, 163, 173, 20, 144, 1, 148, 61, 105, 198, 246, 186, 248, 126, 100, 142, 118, 94, 54, 95, 154, 234, 132, 192, 106, 48, 111, 234},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.HashNodePair(tt.left, tt.right)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"HashNodePair of %d and %d = %d, expected %d",
					tt.left,
					tt.right,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashPairlessNode(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected []byte
	}{
		{
			"A",
			[]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			[]byte{75, 222, 125, 92, 63, 68, 131, 172, 22, 66, 192, 247, 32, 120, 206, 56, 99, 156, 202, 102, 82, 156, 228, 1, 190, 98, 0, 208, 49, 148, 240, 165},
		},
		{
			"B",
			[]byte{31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			[]byte{38, 150, 0, 23, 219, 182, 10, 252, 128, 223, 204, 90, 108, 203, 250, 23, 113, 29, 233, 233, 52, 164, 106, 228, 83, 42, 121, 172, 51, 52, 74, 2},
		},
		{
			"C",
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			[]byte{235, 20, 238, 191, 106, 175, 69, 210, 45, 32, 162, 2, 184, 51, 241, 212, 132, 96, 48, 68, 222, 161, 136, 168, 235, 21, 133, 194, 45, 1, 164, 31},
		},
		{
			"D",
			[]byte{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
			[]byte{47, 143, 15, 38, 231, 247, 103, 199, 222, 167, 30, 117, 191, 79, 112, 81, 13, 181, 176, 95, 80, 232, 66, 238, 182, 220, 9, 214, 120, 184, 118, 64},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.HashPairlessNode(tt.input)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"HashPairlessNode of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashRoot(t *testing.T) {
	tests := []struct {
		name      string
		leafCount int
		root      []byte
		expected  []byte
	}{
		{
			"A",
			1,
			[]byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},
			[]byte{66, 189, 252, 191, 133, 247, 232, 170, 250, 133, 164, 196, 206, 153, 92, 15, 132, 19, 34, 85, 3, 216, 181, 174, 170, 218, 167, 160, 68, 8, 58, 203},
		},
		{
			"B",
			78,
			[]byte{31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},
			[]byte{218, 4, 251, 251, 172, 40, 8, 3, 158, 175, 52, 130, 159, 187, 48, 223, 136, 85, 193, 88, 151, 133, 203, 87, 100, 226, 59, 27, 50, 253, 37, 55},
		},
		{
			"C",
			46984,
			[]byte{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
			[]byte{107, 209, 73, 27, 127, 209, 56, 1, 186, 206, 64, 134, 9, 36, 137, 168, 227, 74, 192, 193, 89, 32, 209, 173, 121, 33, 224, 244, 2, 234, 230, 62},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.HashRoot(tt.leafCount, tt.root)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"HashRoot of %d and %d = %d, expected %d",
					tt.leafCount,
					tt.root,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestIntToBytes32(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected []byte
	}{
		{
			"A",
			0,
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		},
		{
			"B",
			1,
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
		},
		{
			"C",
			78,
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78},
		},
		{
			"D",
			46984,
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 136},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.IntToBytes32(tt.input)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"IntToBytes32 of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestBytes32ToInt(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected int
	}{
		{
			"A",
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			0,
		},
		{
			"B",
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			1,
		},
		{
			"C",
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78},
			78,
		},
		{
			"D",
			[]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 183, 136},
			46984,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.Bytes32ToInt(tt.input)
			if result != tt.expected {
				t.Errorf(
					"Bytes32ToInt of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}
