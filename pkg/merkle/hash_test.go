package merkle_test

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/xmtp/xmtpd/pkg/merkle"
)

func TestHash(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected []byte
	}{
		{
			"A",
			[]byte("Hello"),
			[]byte{
				6,
				179,
				223,
				174,
				193,
				72,
				251,
				27,
				178,
				176,
				102,
				241,
				14,
				194,
				133,
				231,
				201,
				191,
				64,
				42,
				179,
				42,
				167,
				138,
				93,
				56,
				227,
				69,
				102,
				129,
				12,
				210,
			},
		},
		{
			"B",
			[]byte("World"),
			[]byte{
				242,
				32,
				140,
				150,
				125,
				240,
				137,
				246,
				4,
				32,
				120,
				87,
				149,
				192,
				169,
				186,
				136,
				150,
				176,
				246,
				241,
				134,
				127,
				167,
				241,
				241,
				42,
				214,
				247,
				156,
				26,
				24,
			},
		},
		{
			"C",
			[]byte("Lorem ipsum dolor sit amet"),
			[]byte{
				181,
				59,
				124,
				165,
				21,
				5,
				29,
				73,
				232,
				81,
				192,
				123,
				208,
				251,
				221,
				219,
				128,
				16,
				169,
				54,
				111,
				91,
				31,
				95,
				183,
				55,
				186,
				33,
				164,
				53,
				99,
				1,
			},
		},
		{
			"D",
			[]byte("Lorem ipsum dolor sit amet consectetur adipiscing elit"),
			[]byte{
				220,
				97,
				186,
				80,
				239,
				126,
				118,
				1,
				135,
				119,
				215,
				176,
				233,
				190,
				140,
				95,
				143,
				146,
				142,
				230,
				89,
				123,
				151,
				144,
				81,
				148,
				234,
				226,
				116,
				108,
				221,
				129,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.Hash(tt.input)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"Hash of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashLeaf(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected []byte
	}{
		{
			"A",
			[]byte("Hello"),
			[]byte{
				11,
				143,
				170,
				141,
				208,
				138,
				23,
				46,
				191,
				149,
				130,
				239,
				28,
				115,
				208,
				106,
				130,
				226,
				141,
				24,
				198,
				26,
				139,
				71,
				177,
				61,
				1,
				241,
				116,
				14,
				154,
				17,
			},
		},
		{
			"B",
			[]byte("World"),
			[]byte{
				129,
				125,
				90,
				71,
				216,
				243,
				130,
				116,
				25,
				154,
				245,
				121,
				7,
				170,
				32,
				166,
				51,
				165,
				247,
				103,
				67,
				156,
				252,
				34,
				225,
				26,
				93,
				213,
				164,
				73,
				63,
				42,
			},
		},
		{
			"C",
			[]byte("Lorem ipsum dolor sit amet"),
			[]byte{
				165,
				220,
				67,
				4,
				77,
				184,
				119,
				172,
				239,
				129,
				129,
				176,
				75,
				120,
				168,
				28,
				57,
				160,
				29,
				139,
				167,
				142,
				41,
				165,
				254,
				6,
				169,
				151,
				50,
				230,
				38,
				211,
			},
		},
		{
			"D",
			[]byte("Lorem ipsum dolor sit amet consectetur adipiscing elit"),
			[]byte{
				165,
				254,
				22,
				5,
				66,
				70,
				236,
				85,
				180,
				196,
				243,
				118,
				228,
				50,
				204,
				233,
				245,
				215,
				233,
				198,
				133,
				155,
				242,
				128,
				28,
				29,
				5,
				224,
				161,
				135,
				52,
				28,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.HashLeaf(tt.input)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"HashLeaf of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashNodePair(t *testing.T) {
	tests := []struct {
		name     string
		left     []byte
		right    []byte
		expected []byte
	}{
		{
			"A",
			[]byte{
				0,
				1,
				2,
				3,
				4,
				5,
				6,
				7,
				8,
				9,
				10,
				11,
				12,
				13,
				14,
				15,
				16,
				17,
				18,
				19,
				20,
				21,
				22,
				23,
				24,
				25,
				26,
				27,
				28,
				29,
				30,
				31,
			},
			[]byte{
				0,
				1,
				2,
				3,
				4,
				5,
				6,
				7,
				8,
				9,
				10,
				11,
				12,
				13,
				14,
				15,
				16,
				17,
				18,
				19,
				20,
				21,
				22,
				23,
				24,
				25,
				26,
				27,
				28,
				29,
				30,
				31,
			},
			[]byte{
				48,
				192,
				143,
				23,
				252,
				166,
				213,
				177,
				131,
				253,
				121,
				141,
				242,
				201,
				75,
				229,
				95,
				145,
				145,
				170,
				23,
				182,
				78,
				20,
				175,
				36,
				222,
				165,
				29,
				86,
				162,
				0,
			},
		},
		{
			"B",
			[]byte{
				0,
				1,
				2,
				3,
				4,
				5,
				6,
				7,
				8,
				9,
				10,
				11,
				12,
				13,
				14,
				15,
				16,
				17,
				18,
				19,
				20,
				21,
				22,
				23,
				24,
				25,
				26,
				27,
				28,
				29,
				30,
				31,
			},
			[]byte{
				31,
				30,
				29,
				28,
				27,
				26,
				25,
				24,
				23,
				22,
				21,
				20,
				19,
				18,
				17,
				16,
				15,
				14,
				13,
				12,
				11,
				10,
				9,
				8,
				7,
				6,
				5,
				4,
				3,
				2,
				1,
				0,
			},
			[]byte{
				175,
				69,
				169,
				211,
				205,
				37,
				100,
				136,
				146,
				142,
				150,
				69,
				138,
				15,
				230,
				189,
				230,
				24,
				44,
				65,
				109,
				173,
				98,
				40,
				193,
				89,
				0,
				87,
				10,
				212,
				206,
				134,
			},
		},
		{
			"C",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			[]byte{
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
			},
			[]byte{
				207,
				134,
				175,
				117,
				168,
				163,
				173,
				20,
				144,
				1,
				148,
				61,
				105,
				198,
				246,
				186,
				248,
				126,
				100,
				142,
				118,
				94,
				54,
				95,
				154,
				234,
				132,
				192,
				106,
				48,
				111,
				234,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.HashNodePair(tt.left, tt.right)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"HashNodePair of %d and %d = %d, expected %d",
					tt.left,
					tt.right,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashPairlessNode(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected []byte
	}{
		{
			"A",
			[]byte{
				0,
				1,
				2,
				3,
				4,
				5,
				6,
				7,
				8,
				9,
				10,
				11,
				12,
				13,
				14,
				15,
				16,
				17,
				18,
				19,
				20,
				21,
				22,
				23,
				24,
				25,
				26,
				27,
				28,
				29,
				30,
				31,
			},
			[]byte{
				75,
				222,
				125,
				92,
				63,
				68,
				131,
				172,
				22,
				66,
				192,
				247,
				32,
				120,
				206,
				56,
				99,
				156,
				202,
				102,
				82,
				156,
				228,
				1,
				190,
				98,
				0,
				208,
				49,
				148,
				240,
				165,
			},
		},
		{
			"B",
			[]byte{
				31,
				30,
				29,
				28,
				27,
				26,
				25,
				24,
				23,
				22,
				21,
				20,
				19,
				18,
				17,
				16,
				15,
				14,
				13,
				12,
				11,
				10,
				9,
				8,
				7,
				6,
				5,
				4,
				3,
				2,
				1,
				0,
			},
			[]byte{
				38,
				150,
				0,
				23,
				219,
				182,
				10,
				252,
				128,
				223,
				204,
				90,
				108,
				203,
				250,
				23,
				113,
				29,
				233,
				233,
				52,
				164,
				106,
				228,
				83,
				42,
				121,
				172,
				51,
				52,
				74,
				2,
			},
		},
		{
			"C",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			[]byte{
				235,
				20,
				238,
				191,
				106,
				175,
				69,
				210,
				45,
				32,
				162,
				2,
				184,
				51,
				241,
				212,
				132,
				96,
				48,
				68,
				222,
				161,
				136,
				168,
				235,
				21,
				133,
				194,
				45,
				1,
				164,
				31,
			},
		},
		{
			"D",
			[]byte{
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
			},
			[]byte{
				47,
				143,
				15,
				38,
				231,
				247,
				103,
				199,
				222,
				167,
				30,
				117,
				191,
				79,
				112,
				81,
				13,
				181,
				176,
				95,
				80,
				232,
				66,
				238,
				182,
				220,
				9,
				214,
				120,
				184,
				118,
				64,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := merkle.HashPairlessNode(tt.input)
			if !bytes.Equal(result, tt.expected) {
				t.Errorf(
					"HashPairlessNode of %d = %d, expected %d",
					tt.input,
					result,
					tt.expected,
				)
			}
		})
	}
}

func TestHashRoot(t *testing.T) {
	tests := []struct {
		name      string
		leafCount int
		root      []byte
		expected  []byte
		wantErr   bool
	}{
		{
			"leaf count is 1",
			1,
			[]byte{
				0,
				1,
				2,
				3,
				4,
				5,
				6,
				7,
				8,
				9,
				10,
				11,
				12,
				13,
				14,
				15,
				16,
				17,
				18,
				19,
				20,
				21,
				22,
				23,
				24,
				25,
				26,
				27,
				28,
				29,
				30,
				31,
			},
			[]byte{
				66,
				189,
				252,
				191,
				133,
				247,
				232,
				170,
				250,
				133,
				164,
				196,
				206,
				153,
				92,
				15,
				132,
				19,
				34,
				85,
				3,
				216,
				181,
				174,
				170,
				218,
				167,
				160,
				68,
				8,
				58,
				203,
			},
			false,
		},
		{
			"leaf count is 78",
			78,
			[]byte{
				31,
				30,
				29,
				28,
				27,
				26,
				25,
				24,
				23,
				22,
				21,
				20,
				19,
				18,
				17,
				16,
				15,
				14,
				13,
				12,
				11,
				10,
				9,
				8,
				7,
				6,
				5,
				4,
				3,
				2,
				1,
				0,
			},
			[]byte{
				218,
				4,
				251,
				251,
				172,
				40,
				8,
				3,
				158,
				175,
				52,
				130,
				159,
				187,
				48,
				223,
				136,
				85,
				193,
				88,
				151,
				133,
				203,
				87,
				100,
				226,
				59,
				27,
				50,
				253,
				37,
				55,
			},
			false,
		},
		{
			"leaf count is 46984",
			46984,
			[]byte{
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
				255,
			},
			[]byte{
				107,
				209,
				73,
				27,
				127,
				209,
				56,
				1,
				186,
				206,
				64,
				134,
				9,
				36,
				137,
				168,
				227,
				74,
				192,
				193,
				89,
				32,
				209,
				173,
				121,
				33,
				224,
				244,
				2,
				234,
				230,
				62,
			},
			false,
		},
		{
			"leaf count is negative",
			-1,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			true,
		},
		{
			"leaf count is larger than a 32-bit signed int",
			1 << 31,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := merkle.HashRoot(tt.leafCount, tt.root)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				if !bytes.Equal(result, tt.expected) {
					t.Errorf(
						"HashRoot of %d and %d = %d, expected %d",
						tt.leafCount,
						tt.root,
						result,
						tt.expected,
					)
				}
			}
		})
	}
}

func TestIntToBytes32(t *testing.T) {
	tests := []struct {
		name     string
		input    int
		expected []byte
		wantErr  bool
	}{
		{
			"0",
			0,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			false,
		},
		{
			"1",
			1,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				1,
			},
			false,
		},
		{
			"78",
			78,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				78,
			},
			false,
		},
		{
			"46984",
			46984,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				183,
				136,
			},
			false,
		},
		{
			"Negative input",
			-1,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			true,
		},
		{
			"1<<31",
			1 << 31,
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := merkle.IntToBytes32(tt.input)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				if !bytes.Equal(result, tt.expected) {
					t.Errorf(
						"IntToBytes32 of %d = %d, expected %d",
						tt.input,
						result,
						tt.expected,
					)
				}
			}
		})
	}
}

func TestBytes32ToInt(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected int
		wantErr  bool
	}{
		{
			"0",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
			},
			0,
			false,
		},
		{
			"1",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				1,
			},
			1,
			false,
		},
		{
			"78",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				78,
			},
			78,
			false,
		},
		{
			"46984",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				183,
				136,
			},
			46984,
			false,
		},
		{
			"less than 32 bytes",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				183,
				136,
			},
			0,
			true,
		},
		{
			"more than 32 bytes",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				183,
				136,
			},
			0,
			true,
		},
		{
			"non-zero in first 28 bytes",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0,
			},
			0,
			true,
		},
		{
			"larger than a max signed 32-bit value",
			[]byte{
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				255,
				255,
				255,
				255,
			},
			0,
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := merkle.Bytes32ToInt(tt.input)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				if result != tt.expected {
					t.Errorf(
						"Bytes32ToInt of %d = %d, expected %d",
						tt.input,
						result,
						tt.expected,
					)
				}
			}
		})
	}
}
