// Code generated by mockery v2.53.5. DO NOT EDIT.

package fees

import (
	context "context"

	currency "github.com/xmtp/xmtpd/pkg/currency"

	mock "github.com/stretchr/testify/mock"

	queries "github.com/xmtp/xmtpd/pkg/db/queries"

	time "time"
)

// MockIFeeCalculator is an autogenerated mock type for the IFeeCalculator type
type MockIFeeCalculator struct {
	mock.Mock
}

type MockIFeeCalculator_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIFeeCalculator) EXPECT() *MockIFeeCalculator_Expecter {
	return &MockIFeeCalculator_Expecter{mock: &_m.Mock}
}

// CalculateBaseFee provides a mock function with given fields: messageTime, messageSize, storageDurationDays
func (_m *MockIFeeCalculator) CalculateBaseFee(messageTime time.Time, messageSize int64, storageDurationDays uint32) (currency.PicoDollar, error) {
	ret := _m.Called(messageTime, messageSize, storageDurationDays)

	if len(ret) == 0 {
		panic("no return value specified for CalculateBaseFee")
	}

	var r0 currency.PicoDollar
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time, int64, uint32) (currency.PicoDollar, error)); ok {
		return rf(messageTime, messageSize, storageDurationDays)
	}
	if rf, ok := ret.Get(0).(func(time.Time, int64, uint32) currency.PicoDollar); ok {
		r0 = rf(messageTime, messageSize, storageDurationDays)
	} else {
		r0 = ret.Get(0).(currency.PicoDollar)
	}

	if rf, ok := ret.Get(1).(func(time.Time, int64, uint32) error); ok {
		r1 = rf(messageTime, messageSize, storageDurationDays)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIFeeCalculator_CalculateBaseFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalculateBaseFee'
type MockIFeeCalculator_CalculateBaseFee_Call struct {
	*mock.Call
}

// CalculateBaseFee is a helper method to define mock.On call
//   - messageTime time.Time
//   - messageSize int64
//   - storageDurationDays uint32
func (_e *MockIFeeCalculator_Expecter) CalculateBaseFee(messageTime interface{}, messageSize interface{}, storageDurationDays interface{}) *MockIFeeCalculator_CalculateBaseFee_Call {
	return &MockIFeeCalculator_CalculateBaseFee_Call{Call: _e.mock.On("CalculateBaseFee", messageTime, messageSize, storageDurationDays)}
}

func (_c *MockIFeeCalculator_CalculateBaseFee_Call) Run(run func(messageTime time.Time, messageSize int64, storageDurationDays uint32)) *MockIFeeCalculator_CalculateBaseFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(time.Time), args[1].(int64), args[2].(uint32))
	})
	return _c
}

func (_c *MockIFeeCalculator_CalculateBaseFee_Call) Return(_a0 currency.PicoDollar, _a1 error) *MockIFeeCalculator_CalculateBaseFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIFeeCalculator_CalculateBaseFee_Call) RunAndReturn(run func(time.Time, int64, uint32) (currency.PicoDollar, error)) *MockIFeeCalculator_CalculateBaseFee_Call {
	_c.Call.Return(run)
	return _c
}

// CalculateCongestionFee provides a mock function with given fields: ctx, querier, messageTime, originatorID
func (_m *MockIFeeCalculator) CalculateCongestionFee(ctx context.Context, querier *queries.Queries, messageTime time.Time, originatorID uint32) (currency.PicoDollar, error) {
	ret := _m.Called(ctx, querier, messageTime, originatorID)

	if len(ret) == 0 {
		panic("no return value specified for CalculateCongestionFee")
	}

	var r0 currency.PicoDollar
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *queries.Queries, time.Time, uint32) (currency.PicoDollar, error)); ok {
		return rf(ctx, querier, messageTime, originatorID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *queries.Queries, time.Time, uint32) currency.PicoDollar); ok {
		r0 = rf(ctx, querier, messageTime, originatorID)
	} else {
		r0 = ret.Get(0).(currency.PicoDollar)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *queries.Queries, time.Time, uint32) error); ok {
		r1 = rf(ctx, querier, messageTime, originatorID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIFeeCalculator_CalculateCongestionFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalculateCongestionFee'
type MockIFeeCalculator_CalculateCongestionFee_Call struct {
	*mock.Call
}

// CalculateCongestionFee is a helper method to define mock.On call
//   - ctx context.Context
//   - querier *queries.Queries
//   - messageTime time.Time
//   - originatorID uint32
func (_e *MockIFeeCalculator_Expecter) CalculateCongestionFee(ctx interface{}, querier interface{}, messageTime interface{}, originatorID interface{}) *MockIFeeCalculator_CalculateCongestionFee_Call {
	return &MockIFeeCalculator_CalculateCongestionFee_Call{Call: _e.mock.On("CalculateCongestionFee", ctx, querier, messageTime, originatorID)}
}

func (_c *MockIFeeCalculator_CalculateCongestionFee_Call) Run(run func(ctx context.Context, querier *queries.Queries, messageTime time.Time, originatorID uint32)) *MockIFeeCalculator_CalculateCongestionFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*queries.Queries), args[2].(time.Time), args[3].(uint32))
	})
	return _c
}

func (_c *MockIFeeCalculator_CalculateCongestionFee_Call) Return(_a0 currency.PicoDollar, _a1 error) *MockIFeeCalculator_CalculateCongestionFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIFeeCalculator_CalculateCongestionFee_Call) RunAndReturn(run func(context.Context, *queries.Queries, time.Time, uint32) (currency.PicoDollar, error)) *MockIFeeCalculator_CalculateCongestionFee_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIFeeCalculator creates a new instance of MockIFeeCalculator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIFeeCalculator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIFeeCalculator {
	mock := &MockIFeeCalculator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
