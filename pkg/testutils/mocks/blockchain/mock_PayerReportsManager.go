// Code generated by mockery v2.53.5. DO NOT EDIT.

package blockchain

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"
	mock "github.com/stretchr/testify/mock"
	blockchain "github.com/xmtp/xmtpd/pkg/blockchain"
	merkle "github.com/xmtp/xmtpd/pkg/merkle"
	payerreport "github.com/xmtp/xmtpd/pkg/payerreport"
)

// MockPayerReportsManager is an autogenerated mock type for the PayerReportsManager type
type MockPayerReportsManager struct {
	mock.Mock
}

type MockPayerReportsManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPayerReportsManager) EXPECT() *MockPayerReportsManager_Expecter {
	return &MockPayerReportsManager_Expecter{mock: &_m.Mock}
}

// GetDomainSeparator provides a mock function with given fields: ctx
func (_m *MockPayerReportsManager) GetDomainSeparator(ctx context.Context) (common.Hash, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetDomainSeparator")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (common.Hash, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) common.Hash); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayerReportsManager_GetDomainSeparator_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDomainSeparator'
type MockPayerReportsManager_GetDomainSeparator_Call struct {
	*mock.Call
}

// GetDomainSeparator is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPayerReportsManager_Expecter) GetDomainSeparator(ctx interface{}) *MockPayerReportsManager_GetDomainSeparator_Call {
	return &MockPayerReportsManager_GetDomainSeparator_Call{Call: _e.mock.On("GetDomainSeparator", ctx)}
}

func (_c *MockPayerReportsManager_GetDomainSeparator_Call) Run(run func(ctx context.Context)) *MockPayerReportsManager_GetDomainSeparator_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPayerReportsManager_GetDomainSeparator_Call) Return(_a0 common.Hash, _a1 error) *MockPayerReportsManager_GetDomainSeparator_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayerReportsManager_GetDomainSeparator_Call) RunAndReturn(run func(context.Context) (common.Hash, error)) *MockPayerReportsManager_GetDomainSeparator_Call {
	_c.Call.Return(run)
	return _c
}

// GetReport provides a mock function with given fields: ctx, originatorNodeID, index
func (_m *MockPayerReportsManager) GetReport(ctx context.Context, originatorNodeID uint32, index uint64) (*payerreport.PayerReport, error) {
	ret := _m.Called(ctx, originatorNodeID, index)

	if len(ret) == 0 {
		panic("no return value specified for GetReport")
	}

	var r0 *payerreport.PayerReport
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) (*payerreport.PayerReport, error)); ok {
		return rf(ctx, originatorNodeID, index)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) *payerreport.PayerReport); ok {
		r0 = rf(ctx, originatorNodeID, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*payerreport.PayerReport)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint64) error); ok {
		r1 = rf(ctx, originatorNodeID, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayerReportsManager_GetReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReport'
type MockPayerReportsManager_GetReport_Call struct {
	*mock.Call
}

// GetReport is a helper method to define mock.On call
//   - ctx context.Context
//   - originatorNodeID uint32
//   - index uint64
func (_e *MockPayerReportsManager_Expecter) GetReport(ctx interface{}, originatorNodeID interface{}, index interface{}) *MockPayerReportsManager_GetReport_Call {
	return &MockPayerReportsManager_GetReport_Call{Call: _e.mock.On("GetReport", ctx, originatorNodeID, index)}
}

func (_c *MockPayerReportsManager_GetReport_Call) Run(run func(ctx context.Context, originatorNodeID uint32, index uint64)) *MockPayerReportsManager_GetReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32), args[2].(uint64))
	})
	return _c
}

func (_c *MockPayerReportsManager_GetReport_Call) Return(_a0 *payerreport.PayerReport, _a1 error) *MockPayerReportsManager_GetReport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayerReportsManager_GetReport_Call) RunAndReturn(run func(context.Context, uint32, uint64) (*payerreport.PayerReport, error)) *MockPayerReportsManager_GetReport_Call {
	_c.Call.Return(run)
	return _c
}

// GetReportID provides a mock function with given fields: ctx, payerReport
func (_m *MockPayerReportsManager) GetReportID(ctx context.Context, payerReport *payerreport.PayerReportWithStatus) (payerreport.ReportID, error) {
	ret := _m.Called(ctx, payerReport)

	if len(ret) == 0 {
		panic("no return value specified for GetReportID")
	}

	var r0 payerreport.ReportID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *payerreport.PayerReportWithStatus) (payerreport.ReportID, error)); ok {
		return rf(ctx, payerReport)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *payerreport.PayerReportWithStatus) payerreport.ReportID); ok {
		r0 = rf(ctx, payerReport)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(payerreport.ReportID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *payerreport.PayerReportWithStatus) error); ok {
		r1 = rf(ctx, payerReport)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayerReportsManager_GetReportID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReportID'
type MockPayerReportsManager_GetReportID_Call struct {
	*mock.Call
}

// GetReportID is a helper method to define mock.On call
//   - ctx context.Context
//   - payerReport *payerreport.PayerReportWithStatus
func (_e *MockPayerReportsManager_Expecter) GetReportID(ctx interface{}, payerReport interface{}) *MockPayerReportsManager_GetReportID_Call {
	return &MockPayerReportsManager_GetReportID_Call{Call: _e.mock.On("GetReportID", ctx, payerReport)}
}

func (_c *MockPayerReportsManager_GetReportID_Call) Run(run func(ctx context.Context, payerReport *payerreport.PayerReportWithStatus)) *MockPayerReportsManager_GetReportID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*payerreport.PayerReportWithStatus))
	})
	return _c
}

func (_c *MockPayerReportsManager_GetReportID_Call) Return(_a0 payerreport.ReportID, _a1 error) *MockPayerReportsManager_GetReportID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayerReportsManager_GetReportID_Call) RunAndReturn(run func(context.Context, *payerreport.PayerReportWithStatus) (payerreport.ReportID, error)) *MockPayerReportsManager_GetReportID_Call {
	_c.Call.Return(run)
	return _c
}

// SettleReport provides a mock function with given fields: ctx, originatorNodeID, index, proof
func (_m *MockPayerReportsManager) SettleReport(ctx context.Context, originatorNodeID uint32, index uint64, proof *merkle.MultiProof) error {
	ret := _m.Called(ctx, originatorNodeID, index, proof)

	if len(ret) == 0 {
		panic("no return value specified for SettleReport")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64, *merkle.MultiProof) error); ok {
		r0 = rf(ctx, originatorNodeID, index, proof)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockPayerReportsManager_SettleReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SettleReport'
type MockPayerReportsManager_SettleReport_Call struct {
	*mock.Call
}

// SettleReport is a helper method to define mock.On call
//   - ctx context.Context
//   - originatorNodeID uint32
//   - index uint64
//   - proof *merkle.MultiProof
func (_e *MockPayerReportsManager_Expecter) SettleReport(ctx interface{}, originatorNodeID interface{}, index interface{}, proof interface{}) *MockPayerReportsManager_SettleReport_Call {
	return &MockPayerReportsManager_SettleReport_Call{Call: _e.mock.On("SettleReport", ctx, originatorNodeID, index, proof)}
}

func (_c *MockPayerReportsManager_SettleReport_Call) Run(run func(ctx context.Context, originatorNodeID uint32, index uint64, proof *merkle.MultiProof)) *MockPayerReportsManager_SettleReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32), args[2].(uint64), args[3].(*merkle.MultiProof))
	})
	return _c
}

func (_c *MockPayerReportsManager_SettleReport_Call) Return(_a0 error) *MockPayerReportsManager_SettleReport_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPayerReportsManager_SettleReport_Call) RunAndReturn(run func(context.Context, uint32, uint64, *merkle.MultiProof) error) *MockPayerReportsManager_SettleReport_Call {
	_c.Call.Return(run)
	return _c
}

// SettlementSummary provides a mock function with given fields: ctx, originatorNodeID, index
func (_m *MockPayerReportsManager) SettlementSummary(ctx context.Context, originatorNodeID uint32, index uint64) (*blockchain.SettlementSummary, error) {
	ret := _m.Called(ctx, originatorNodeID, index)

	if len(ret) == 0 {
		panic("no return value specified for SettlementSummary")
	}

	var r0 *blockchain.SettlementSummary
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) (*blockchain.SettlementSummary, error)); ok {
		return rf(ctx, originatorNodeID, index)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) *blockchain.SettlementSummary); ok {
		r0 = rf(ctx, originatorNodeID, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blockchain.SettlementSummary)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32, uint64) error); ok {
		r1 = rf(ctx, originatorNodeID, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPayerReportsManager_SettlementSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SettlementSummary'
type MockPayerReportsManager_SettlementSummary_Call struct {
	*mock.Call
}

// SettlementSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - originatorNodeID uint32
//   - index uint64
func (_e *MockPayerReportsManager_Expecter) SettlementSummary(ctx interface{}, originatorNodeID interface{}, index interface{}) *MockPayerReportsManager_SettlementSummary_Call {
	return &MockPayerReportsManager_SettlementSummary_Call{Call: _e.mock.On("SettlementSummary", ctx, originatorNodeID, index)}
}

func (_c *MockPayerReportsManager_SettlementSummary_Call) Run(run func(ctx context.Context, originatorNodeID uint32, index uint64)) *MockPayerReportsManager_SettlementSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint32), args[2].(uint64))
	})
	return _c
}

func (_c *MockPayerReportsManager_SettlementSummary_Call) Return(_a0 *blockchain.SettlementSummary, _a1 error) *MockPayerReportsManager_SettlementSummary_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayerReportsManager_SettlementSummary_Call) RunAndReturn(run func(context.Context, uint32, uint64) (*blockchain.SettlementSummary, error)) *MockPayerReportsManager_SettlementSummary_Call {
	_c.Call.Return(run)
	return _c
}

// SubmitPayerReport provides a mock function with given fields: ctx, report
func (_m *MockPayerReportsManager) SubmitPayerReport(ctx context.Context, report *payerreport.PayerReportWithStatus) (int32, blockchain.ProtocolError) {
	ret := _m.Called(ctx, report)

	if len(ret) == 0 {
		panic("no return value specified for SubmitPayerReport")
	}

	var r0 int32
	var r1 blockchain.ProtocolError
	if rf, ok := ret.Get(0).(func(context.Context, *payerreport.PayerReportWithStatus) (int32, blockchain.ProtocolError)); ok {
		return rf(ctx, report)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *payerreport.PayerReportWithStatus) int32); ok {
		r0 = rf(ctx, report)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *payerreport.PayerReportWithStatus) blockchain.ProtocolError); ok {
		r1 = rf(ctx, report)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(blockchain.ProtocolError)
		}
	}

	return r0, r1
}

// MockPayerReportsManager_SubmitPayerReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubmitPayerReport'
type MockPayerReportsManager_SubmitPayerReport_Call struct {
	*mock.Call
}

// SubmitPayerReport is a helper method to define mock.On call
//   - ctx context.Context
//   - report *payerreport.PayerReportWithStatus
func (_e *MockPayerReportsManager_Expecter) SubmitPayerReport(ctx interface{}, report interface{}) *MockPayerReportsManager_SubmitPayerReport_Call {
	return &MockPayerReportsManager_SubmitPayerReport_Call{Call: _e.mock.On("SubmitPayerReport", ctx, report)}
}

func (_c *MockPayerReportsManager_SubmitPayerReport_Call) Run(run func(ctx context.Context, report *payerreport.PayerReportWithStatus)) *MockPayerReportsManager_SubmitPayerReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*payerreport.PayerReportWithStatus))
	})
	return _c
}

func (_c *MockPayerReportsManager_SubmitPayerReport_Call) Return(_a0 int32, _a1 blockchain.ProtocolError) *MockPayerReportsManager_SubmitPayerReport_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPayerReportsManager_SubmitPayerReport_Call) RunAndReturn(run func(context.Context, *payerreport.PayerReportWithStatus) (int32, blockchain.ProtocolError)) *MockPayerReportsManager_SubmitPayerReport_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPayerReportsManager creates a new instance of MockPayerReportsManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPayerReportsManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPayerReportsManager {
	mock := &MockPayerReportsManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
